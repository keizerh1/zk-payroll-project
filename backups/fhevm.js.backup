import { createInstance } from 'fhevmjs';

let fheInstance = null;

/**
 * Initialise l'instance FHE avec le provider
 * @param {ethers.Provider} provider - Provider Ethereum
 * @returns {Promise<Object>} Instance FHE initialisée
 */
export async function initializeFHE(provider) {
  if (fheInstance) {
    return fheInstance;
  }

  try {
    // Obtenir la clé publique du réseau
    const network = await provider.getNetwork();
    const chainId = Number(network.chainId);

    // Créer l'instance FHE
    fheInstance = await createInstance({
      chainId,
      publicKey: await getPublicKey(provider, chainId),
      gatewayUrl: getGatewayUrl(chainId),
    });

    console.log('✅ Instance FHE initialisée pour chainId:', chainId);
    return fheInstance;
  } catch (error) {
    console.error('❌ Erreur lors de l\'initialisation FHE:', error);
    throw error;
  }
}

/**
 * Obtient l'instance FHE
 * @returns {Object} Instance FHE
 */
export function getFHEInstance() {
  if (!fheInstance) {
    throw new Error('FHE non initialisé. Appelez initializeFHE() d\'abord.');
  }
  return fheInstance;
}

/**
 * Chiffre un nombre avec FHE
 * @param {number} value - Valeur à chiffrer
 * @returns {Promise<Object>} Valeur chiffrée avec preuve
 */
export async function encryptValue(value) {
  const instance = getFHEInstance();
  
  try {
    // Convertir en entier 64 bits
    const valueUint64 = BigInt(Math.floor(value));
    
    // Chiffrer avec FHE
    const encrypted = await instance.encrypt64(valueUint64);
    
    return {
      data: encrypted,
      proof: await instance.generateProof(encrypted)
    };
  } catch (error) {
    console.error('Erreur de chiffrement:', error);
    throw error;
  }
}

/**
 * Déchiffre une valeur FHE
 * @param {string} encryptedValue - Valeur chiffrée
 * @param {ethers.Signer} signer - Signer pour la signature
 * @returns {Promise<number>} Valeur déchiffrée
 */
export async function decryptValue(encryptedValue, signer) {
  const instance = getFHEInstance();
  
  try {
    // Créer la signature pour le déchiffrement
    const signature = await createDecryptionSignature(signer);
    
    // Déchiffrer
    const decrypted = await instance.decrypt(encryptedValue, signature);
    
    return Number(decrypted);
  } catch (error) {
    console.error('Erreur de déchiffrement:', error);
    throw error;
  }
}

/**
 * Crée une signature pour le déchiffrement
 * @param {ethers.Signer} signer - Signer
 * @returns {Promise<string>} Signature
 */
async function createDecryptionSignature(signer) {
  const message = 'Authorize decryption';
  const signature = await signer.signMessage(message);
  return signature;
}

/**
 * Obtient la clé publique du réseau
 * @param {ethers.Provider} provider - Provider
 * @param {number} chainId - ID de la chaîne
 * @returns {Promise<string>} Clé publique
 */
async function getPublicKey(provider, chainId) {
  // Pour le testnet Zama
  if (chainId === 8009) {
    // Clé publique du testnet Zama (à remplacer par la vraie clé)
    return '0x...'; // Obtenir depuis Zama
  }
  
  // Pour d'autres réseaux, appeler un endpoint
  try {
    const response = await fetch(`https://gateway.zama.ai/public-key/${chainId}`);
    const data = await response.json();
    return data.publicKey;
  } catch (error) {
    console.error('Erreur lors de la récupération de la clé publique:', error);
    throw error;
  }
}

/**
 * Obtient l'URL de la gateway FHE
 * @param {number} chainId - ID de la chaîne
 * @returns {string} URL de la gateway
 */
function getGatewayUrl(chainId) {
  const gateways = {
    8009: 'https://gateway.devnet.zama.ai', // Testnet Zama
    31337: 'http://localhost:8545', // Local
  };
  
  return gateways[chainId] || 'https://gateway.zama.ai';
}

/**
 * Chiffre un montant en dollars (avec décimales)
 * @param {number} amount - Montant en dollars (ex: 5000.50)
 * @param {number} decimals - Nombre de décimales (défaut: 6 pour USDC)
 * @returns {Promise<Object>} Montant chiffré
 */
export async function encryptAmount(amount, decimals = 6) {
  // Convertir en unités (ex: 5000.50 -> 5000500000 pour 6 décimales)
  const amountInUnits = Math.floor(amount * Math.pow(10, decimals));
  return await encryptValue(amountInUnits);
}

/**
 * Déchiffre un montant et le convertit en dollars
 * @param {string} encryptedAmount - Montant chiffré
 * @param {ethers.Signer} signer - Signer
 * @param {number} decimals - Nombre de décimales
 * @returns {Promise<number>} Montant en dollars
 */
export async function decryptAmount(encryptedAmount, signer, decimals = 6) {
  const amountInUnits = await decryptValue(encryptedAmount, signer);
  return amountInUnits / Math.pow(10, decimals);
}

/**
 * Chiffre un pourcentage (ex: 25% -> 2500)
 * @param {number} percentage - Pourcentage (ex: 25 pour 25%)
 * @returns {Promise<Object>} Pourcentage chiffré
 */
export async function encryptPercentage(percentage) {
  // Multiplier par 100 pour éviter les décimales (25% -> 2500)
  const percentageValue = Math.floor(percentage * 100);
  return await encryptValue(percentageValue);
}

/**
 * Déchiffre un pourcentage
 * @param {string} encryptedPercentage - Pourcentage chiffré
 * @param {ethers.Signer} signer - Signer
 * @returns {Promise<number>} Pourcentage
 */
export async function decryptPercentage(encryptedPercentage, signer) {
  const percentageValue = await decryptValue(encryptedPercentage, signer);
  return percentageValue / 100;
}

/**
 * Calcule le salaire net à partir du brut et du taux
 * @param {number} grossSalary - Salaire brut
 * @param {number} taxRate - Taux d'imposition (en %)
 * @returns {number} Salaire net
 */
export function calculateNetSalary(grossSalary, taxRate) {
  const taxAmount = (grossSalary * taxRate) / 100;
  return grossSalary - taxAmount;
}

/**
 * Formate un montant en devise
 * @param {number} amount - Montant
 * @param {string} currency - Code de devise
 * @returns {string} Montant formaté
 */
export function formatCurrency(amount, currency = 'USD') {
  return new Intl.NumberFormat('fr-FR', {
    style: 'currency',
    currency: currency,
  }).format(amount);
}

/**
 * Valide un montant de salaire
 * @param {number} amount - Montant à valider
 * @returns {boolean} True si valide
 */
export function validateSalaryAmount(amount) {
  return amount > 0 && amount <= 1000000 && !isNaN(amount);
}

/**
 * Valide un taux d'imposition
 * @param {number} rate - Taux à valider
 * @returns {boolean} True si valide
 */
export function validateTaxRate(rate) {
  return rate >= 0 && rate <= 100 && !isNaN(rate);
}
